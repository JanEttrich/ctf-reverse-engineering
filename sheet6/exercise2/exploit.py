#!/usr/bin/python3

import socket
import telnetlib
import base64
import angr
import claripy
import os

prefix_bytes = b"here's the crackme:\n"
suffix_bytes = b"\nYou have 30 seconds. Solution? "

def receive_elf_and_bin(s):
    data = b''
    while True:
        try:
            received = s.recv(2048)
            data += received
            if b"Solution? " in received:
                break
        except socket.timeout:
            break
    data = data[len(prefix_bytes):]
    data = data[:-len(suffix_bytes)]
    elf = data.split(b"\nand here is the result.bin:\n")[0]
    bin = data.split(b"\nand here is the result.bin:\n")[1]
    return elf, bin
        
def save_file(name, file):
    if not file:
        print(f"No {name} file received")
    else: 
        print(f"{name} file received")

    decoded = base64.b64decode(file)
    with open(name, "wb") as new_file:
        new_file.write(decoded)
        print("File saved successfully")

class SimDirectory(angr.SimFileBase):
    def __init__(self, name, path):
        super().__init__()
        self.name = name
        self.path = path

class SimOpenat(angr.SimProcedure):
    def run(self, dir_fd, p_addr, flags): # only relative paths necesarry
        print("Hello openat!")

        # get path from fd
        dir_fd_res = self.state.posix.get_fd(dir_fd)
        if not dir_fd_res:
            return -1
        fd_path = dir_fd_res.file.name
        if type(fd_path) is str:
            fd_path = fd_path.encode()

        # resolve pathname from memory
        strlen = angr.SIM_PROCEDURES["libc"]["strlen"]
        p_strlen = self.inline_call(strlen, p_addr)
        p_expr = self.state.memory.load(p_addr, p_strlen.max_null_index, endness="Iend_BE")
        path = self.state.solver.eval(p_expr, cast_to=bytes)

        # build path
        full_path = fd_path + b'/' + path
        print(full_path)

        fd = self.state.posix.open(full_path, flags)
        if fd is None:
            return -1
        return fd

class SimMkdirat(angr.SimProcedure):
    def run(self, dir_fd, p_addr):
        print("Hello mkdirat!")

        # get path from fd
        dir_fd_res = self.state.posix.get_fd(dir_fd)
        if not dir_fd_res:
            return -1
        fd_path = dir_fd_res.file.name

        # resolve pathname from memory
        strlen = angr.SIM_PROCEDURES["libc"]["strlen"]
        p_strlen = self.inline_call(strlen, p_addr)
        p_expr = self.state.memory.load(p_addr, p_strlen.max_null_index, endness="Iend_BE")
        path = self.state.solver.eval(p_expr, cast_to=bytes)

        # build path
        full_path = fd_path.encode() + b'/' + path
        print(full_path)

        if not self.state.fs.insert(path, SimDirectory(path, full_path)):
            return -1
        return 0

# start connection
s = socket.create_connection(('localhost', 2002))
elf, bin = receive_elf_and_bin(s)
save_file("binary", elf)
save_file("result.bin", bin)

with open('result.bin', mode='rb') as file:
    fileContent = file.read()
    print(fileContent)

# set up angr project
proj = angr.Project('binary', load_options={'auto_load_libs': False})
proj.hook_symbol('openat', SimOpenat())
proj.hook_symbol('mkdirat', SimMkdirat())
angr.sim_options.ALL_FILES_EXIST = False

# set up initial result.bin file and . directory
file_name = "result.bin"
file_content = fileContent
file_size = len(file_content)
sim_file = angr.SimFile(file_name, content=file_content, size=file_size)

dir_name = "."
sim_dir = SimDirectory(dir_name, path=dir_name)

file_system = {file_name: sim_file, dir_name: sim_dir}

# set up entry state and explore
input_length = 32
input_str = claripy.BVS("input", input_length * 8)
entry_state = proj.factory.entry_state(stdin=angr.SimFileStream(name='stdin', content=input_str, has_end=False), fs=file_system)
simgr = proj.factory.simulation_manager(entry_state)
simgr.explore(find=proj.loader.main_object.get_symbol('print_flag').rebased_addr) 

# extract input and send
assert(len(simgr.found) > 0)
solution_state = simgr.found[0]
solution = solution_state.solver.eval(input_str, cast_to=bytes)
print("Valid input:")
print(solution)
s.send(solution + b'\n')

t = telnetlib.Telnet()
t.sock = s
t.interact()

s.close()