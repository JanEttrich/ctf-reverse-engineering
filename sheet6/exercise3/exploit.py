import angr 


#project = angr.Project('exercise3')
#target_address = 0x004011b6

def add_constraints_to_unconstrained_path(path, target_addr):
    """
    Add constraints to an unconstrained path to guide it towards the target address.
    """
    # Get the state from the path
    state = path.active[0]

    # Determine the instruction pointer (IP) register based on the architecture
    ip_reg_name = state.arch.ip_offset / 8
    ip_reg = getattr(state.regs, ip_reg_name)

    # Add a constraint to force the instruction pointer (IP) to be equal to the target address
    path.add_constraints(ip_reg == target_addr)

def step_func(state):
    """
    Custom step function that adds constraints to unconstrained paths to reach the target address.
    """

    # Get the target address (address of the success function)
    target_addr = state.project.loader.find_symbol('success').rebased_addr

    # Get the current instruction pointer (IP) value
    ip_value = state.solver.eval(state.regs.ip)

    if ip_value == target_addr:
        # We reached the target address, mark the state as found and stop exploration
        state.scratch.success = True
        return

    # For unconstrained paths, add constraints to direct them towards the target address
    add_constraints_to_unconstrained_path(state, target_addr)

# Load the binary and create the simulation manager with save_unconstrained=True
proj = angr.Project("./exercise3", auto_load_libs=False)
state = proj.factory.entry_state()
simgr = proj.factory.simulation_manager(state, save_unconstrained=True)

# Explore the binary with our custom step function
simgr.explore(step_func=step_func)

# Check if we found a state that reached the success function
assert len(simgr.found) > 0

# Get the input that makes the binary reach the success function
input_data = simgr.found[0].posix.dumps(0)




# Execute the binary with the input to check if it reaches the success function
#import subprocess
#process = subprocess.Popen(["./exercise3"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
#output, stderr = process.communicate(input_to_success)

# Assert that the output contains the success message
#assert b"Congrats, you reached the success function!" in output
